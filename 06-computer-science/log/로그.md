# 로그 (Log)
애플리케이션이 실행되는 동안 발생하는 이벤트, 상태 변화, 에러 등을 기록한 텍스트 데이터

보통 다음과 같은 목적으로 사용한다.
- 디버깅: 버그 발생 시 원인 파악
- 모니터링: 시스템 상태 실시간 추적
- 감사(Audit):  보안/규정 준수를 위한 작업 이력 보관
- 성능 분석: 병목 지점 파악
- 장애 대응: 장애 발생 시 신속한 원인 분석

## 로그 레벨
로그 정보에 따라서 필요한 레벨로 설정하여 로깅을 진행한다.
- trace: 매우 상세한 정보
- debug: 개발 중 디버깅 정보
- info: 중요한 비즈니스 프로세스 흐름
- warn: 잠재적 문제 상황(즉시 대응 불필요)
- error: 즉시 대응이 필요한 오류

## Spring에서의 로깅 아키텍처
PSA (Portable Service Abstraction)개념이 적용되어 있다.

> PSA : 환경과 세부 기술이 변경되어도, 애플리케이션 코드는 변경하지 않아도 되도록 하는 추상화 기법

```
┌─────────────────────────────────────────┐
│      애플리케이션 코드 (변경 없음)          │
│    log.info("message")                  │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      추상화 계층 (인터페이스/파사드)         │
│            SLF4J API                    │
└──────────────┬──────────────────────────┘
               │
      ┌────────┴─────────┬─────────┐
      ▼                  ▼         ▼
┌──────────┐      ┌──────────┐  ┌──────────┐
│ Logback  │      │  Log4j2  │  │   JUL    │
│ (구현체1) │      │ (구현체2) │  │ (구현체3) │
└──────────┘      └──────────┘  └──────────┘
```

아래 java 파일을 컴파일하게 되면 다음과 같이 변환된다.

.java 파일

```java
@Slf4j
public class UserService {

}
```

.class파일

```java
public class UserService {
  private static final Logger log = LoggerFactory.getLogger(UserService.class);
}
```

### LoggerFactory의 동작 메커니즘

1. LoggerFactory.getLogger() 호출
2. 클래스패스에서 StaticLoggerBinder 검색
3. 발견된 구현체의 Logger 반환
  - loback-classic -> ch.qos.logback.classic.Logger
  - log4j-slf4j-impl -> org.apache.logging.slf4j.Log4jLogger
  - slf4j-simple → org.slf4j.simple.SimpleLogger

## Appender
로그를 어디에, 어떻게 출력할지 결정하는 컴포넌트

**주요 Appender 종류**
- Console Appender: 콘솔 출력 담당
  - 개발 환경에서 실시간 디버깅
  - Docker 컨테이너 환경 (stdout/stderr -> 로그 수집)
  - 간단한 테스트
- File Appender: 단일 파일 출력
  - 문제점 존재: 파일이 무한정 커짐, 디스크 풀 위험, 오래된 로그 정리 불가
- Rolling File Appender: 로그 파일 순환
  - 보관 기간, 로그 파일 최대 크기, 파일 하나당 최대 크기 등을 설정할 수 있음.
- 그 외, Async Appender, DBAppender, SMTPAppender 등등이 있다.

## MDC (Mapped Diagnostic Context)
로그에 컨텍스트 정보를 자동으로 추가하는 `Thread-Local` 저장

## Log vs System.out.println()

**System.out.println()**
```java
public final class System {
    // PrintStream 객체
    public static final PrintStream out = new PrintStream(...);

    // ...
}

public class PrintStream extends FilterOutputStream {

    public void println(String x) {
        synchronized (this) {  // ← 핵심: 동기화!
            print(x);
            newLine();
        }
    }

    private void newLine() {
        try {
            synchronized (this) {
                // 버퍼 flush
                ensureOpen();
                textOut.newLine();
                textOut.flushBuffer();
                charOut.flushBuffer();

                if (autoFlush)
                    out.flush();  // 즉시 출력
            }
        } catch (IOException x) {
            trouble = true;
        }
    }
}
```

핵심 문제점
1. syncrhronized: 모든 스레드가 순서대로 대기
2. 즉시 flush: 버퍼를 바로 비움 (I/O 작업)

**Log**

``` java
// SLF4J Logger 인터페이스
public interface Logger {
    void info(String format, Object arg);
}

// Logback 구현체
public final class Logger implements org.slf4j.Logger {

    @Override
    public void info(String format, Object arg) {
        // 1. 레벨 체크 (가장 먼저!)
        if (!isInfoEnabled()) {
            return;  // 즉시 리턴 (초고속)
        }

        // 2. 로깅 이벤트 생성
        LoggingEvent event = new LoggingEvent(
            fqcn, this, Level.INFO, format, null, new Object[]{arg}
        );

        // 3. Appender로 전달
        appendLoopOnAppenders(event);
    }

    public boolean isInfoEnabled() {
        // 단순 레벨 비교 (매우 빠름)
        return level.levelInt <= Level.INFO_INT;
    }
}
```

장점
1. 레벨 체크: 불필요한 로그는 즉시 버림
2. 비동기 가능: AsyncAppender 사용 시
3. 버퍼링: 효율적인 I/O
4. 유연한 출력: 파일, 콘솔, DB등.
