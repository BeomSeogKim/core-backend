# 실행 계획


핵심 필드

| 우선순위 | 필드명 | 설명 | 핵심 체크 포인트 |
| -- | -- | -- | -- |
| 1 | type | 데이터 접근 방식 | Full Table Scan인지 인덱스를 타는 지 확인 |
| 2 | key | 실제 사용된 인덱스 | 의도한 인덱스가 실제로 선택되었는 지 확인 |
| 3 | rows | 스캔 예상 행 수 | 쿼리 처리를 위해 몇 줄을 읽어야 하는 가? |
| 4 | Extra | 추가 정보 | Using filesort, Using temporary 등 비효율적인 작업 확인 |
| 5 | filtered | 필터링 비율 | 스토리지 엔진이 읽은 후 실제 결과로 남는 비율 (%) |

## type
MySQL이 데이터를 어떻게 찾는 지 나타내는 필드

- system / const : PK나 Unique Key를 사용하여 단 1건의 데이터만 조회할 때
- eq_ref : 조인 시 PK나 Unique Key로 매칭되어 단 1건만 읽을 때
- ref : 인덱스를 타지만 결과가 1건 이상일 수 있을 때
- range : 인덱스를 사용하여 특정 범위를 검색할 때 (BETWEEN, < , >, IN)
- index : 인덱스 풀 스캔 (인덱스 전체를 다 읽는 방식)
- ALL : 풀 테이블 스캔 (테이블 전체를 처음부터 끝까지 다 읽음)

_위에서 부터 아래로 성능이 좋은 순서이다._

## Extra
쿼리 실행에 대한 구체적인 동작이나 비효율적인 상황을 알려준다.

- Bad
    - Using filesort : 인덱스를 이용해 정렬하지 못하고, 메모리나 디스크에서 별도로 정렬 작업을 수행함
    - Using temporary : 쿼리 처리를 위해 임시 테이블을 생성함. (`Distinct`, `GROUP BY`, `ORDER BY` 수행시 자주 발생하며 디스크 I/O를 유발할 수 있다.)
- Great
    - Using Index : 데이터 파일 접근 없이 인덱스만 읽어 쿼리를 처리 (커버링 인덱스)
- Normal
    - Using where : 스토리지 엔진에서 데이터를 읽어온 뒤, MySQL 엔진에서 필터링을 수행

## rows, filtered
- rows : 쿼리 결과를 찾기 위해 읽어야 할 것으로 예측한 행의 수
- filtered : rows로 읽어온 데이터 중, 최종 조건 (WHERE)에 의해 남을 것으로 예상되는 비율 (%)

_rows는 큰데, filtered가 낮다면 인덱스 효율이 좋지 못하다는 뜻이다._

